## C/C++基础知识

#### 内存分区

        1.堆：由程序员手动分配和释放，完全不同于数据结构中的堆，分配方式类似链表。由malloc（C语言）或new（C++）来分配，free
        （C语言）和delete（C++）释放。若程序员不释放，程序结束时由系统释放。
        
        2.栈：由编译器自动分配和释放，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈。
        
        3.全局（静态）存储区：存放全局变量和静态变量。包括DATA段（全局初始化区）与BSS段（全局未初始化区）。其中，初始化的全局
        变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。程序结束后有系统释放。
        其中BSS段的特点是：在程序执行之前BSS段会自动清0。所以，未初始化的全局变量和静态变量在程序执行之前就已经成0了。
        
        4.文字常量区：常量字符串就放在这里，程序结束后由系统释放。
        
        5.程序代码区：存放函数体的二进制代码。


<br>

#### 类和继承

        #define NAME_SIZE 50
        
        class Person {
                int id;                 // 所有成员默认为私有（private）
                char name[NAME_SIZE];
                
        public:
                void aboutMe()
                {
                        cout << "I am a person.";
                }
        };
        
        class Student ：public Person {
        public:
                void aboutMe()
                {
                        cout << "I am a student.";
                }
        };
        
        Student* p = new Student();
        p->aboutMe();   // 打印“I am a student.”
        delete p;       // 务必释放之前分配的内存
        
        在C++中，所有数据成员和方法均默认为私有（private），可用关键字public修改其属性。


<br>

#### 构造函数和析构函数

        对象创建时会自动调用类的构造函数，如果没有定义构造函数，编译器会自动生成一个默认的构造函数（Default Constructor）。
        自定义构造函数：
                Person(int a) {
                        id  = a;
                }
                或者
                Person(int a) : id(a) { // 成员初值列
                        ...
                }
                在真正对象创建之前，且在构造函数余下代码调用前，数据成员id就会被赋值。在常量数据成员赋值时（只能赋值
                一次），这种写法特别适用。
        
        析构函数会在对象删除时执行清理工作。对象销毁时会自动调用析构函数。我们不会显示的调用析构函数，因此它不能带参数。
                ~Person() {
                        delete obj;     // 释放之前这个类里分配的内存
                }
        
        
        继承时构造函数与析构函数的调用顺序
                创建子类时，先调用基类的构造函数，只有这样子类才能在构造函数里使用基类的成员，然后再调用子类自身的构造
                函数。
                销毁对象时，子类先调用自身的析构函数，再调用基类的析构函数。基类的析构函数必须设置为虚拟的，而作为最终
                子类可以是虚拟也可以是非虚拟的。


<br>

#### 虚函数

        虚函数的定义很简单，只要在成员函数原型前加一个关键字virtual即可。
        
        类的一个成员定义为一个虚函数的实际意义在于让C++知道该函数并无意义，它的作用只是为了让派生类进行函数重定义保留位
        置。
        
        纯虚函数的定义方法就是在类的虚函数后面加上“ = 0 ”标记，类中一旦出现了纯虚函数的定义，那么此类为抽象类，不能实
        例化。为什么不能实例化？因为抽象类中的纯虚函数没有具体的实现，所以没办法实例化。
        
        class Person {
                int id;
                char name[NAME_SIZE];
        public:
                virtual void aboutMe() {
                        cout << "I am a person.";
                }
                
                virtual bool addCourse(string s) = 0;
        };
        
        class Student : public Person {
        public:
                void aboutMe {
                        cout << "I am a Student.";
                }
                
                bool addCourse(string s) {
                        cout << "Added Course " << s << "to student." << endl;
                        return true;
                }
        };
        
        Person* p = new Student();
        p->aboutMe();   // 打印“I am a student.”
        p->addCourse("History");
        delete p;
        
        虚析构函数：
                class Person {
                public:
                        virtual ~Person() {
                                cout << "Deleteing a person." << endl;
                        }
                };
                
                class Student : public Person {
                public:
                        ~Student() {
                                cout << "Deleting a student." << endl;
                        }
                };
                
                Person* p = new Student();
                delete p;
                
                打印输出如下：
                Deleting a student.
                Deleting a person.
        
        虚函数工作原理：
                虚函数需要虚函数表（Virtual Table）才能实现。如果一个类有函数声明成虚拟的，就会生成一个vtable，存放
                这个类的虚函数地址。此外，编译器还会在类里加入隐藏的vptr变量（虚函数指针）。若子类没有覆写虚函数，该
                子类的vtable就会存放父类的函数地址。调用这个虚函数时，就会通过vtable解析函数的地址。
                在C++里，动态绑定就是通过vtable机制实现的。
                每个类都会维护一张虚函数表，编译时，编译器根据类的声明创建出虚函数表，当对象被构造时，虚函数表的地址就
                会被写入这个对象内存的起始位置。运行时从虚函数表中查到真正要执行的函数的地址，然后再将 this 指针传入执
                行。


<br>

#### 构造函数为什么不能为虚函数

        假如有如下的代码：
        class A
        {
                A() {}
        };
        
        class B : public A
        {
                B():A() {}
        };
        
        则构造B的对象时：
        1）根据继承的性质，构造函数执行顺序是：A()B()
        2）根据虚函数的性质，如果A的构造函数为虚函数，且B类也给出了构造函数，则应该只执行B类的构造函数，不再执行A类的
        构造函数。这样A就不能构造了。
        3）这样1和2就发生了矛盾。
        
        另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。


<br>

#### 深拷贝和浅拷贝

        浅拷贝会将对象的所有成员的值拷贝到另一个对象里。除了拷贝所有对象的值，深拷贝还会进一步拷贝所有指针对象。
        
        struct Test {
                char* ptr;
        };
        
        void shallow_copy(Test& src, Test& dest) {
                dest.ptr = src.ptr;
        }
        
        void deep_copy(Test& src, Test& dest) {
                dest.ptr = (char *)malloc(strlen(src.ptr) + 1);
                strcpy(dest.ptr, src.ptr);
        }
        
        shallow_copy可能会导致大量编程运行时错误，尤其是在对象创建和销毁时。使用浅拷贝是必须非常小心，只有当开发人员
        真正知道自己在做些什么的时方可选用浅拷贝。多数情况下，使用浅拷贝是为了传递一块复杂的结构信息，但又不想真的复
        制一份数据。使用浅拷贝时，销毁对象必须非常小心。
        在实际开发中，浅拷贝很少使用。大部分情况都应该使用深拷贝。


<br>

#### 指针和引用

        1）引用必须被初始化，指针不必。
        2）引用初始化以后不能被改变，指针可以改变所指的对象。
        3）不存在指向空值的引用，但是存在指向空值的指针。
        
        指针的大小随着计算机体系结构不同而不同：在32位机器上为32位，在64位机器上为64位。
        

<br>

#### static

        不考虑类，static的作用主要有3条：
        1.隐藏。所有未加static前缀的全局变量和函数都具有全局可见性。如果加了static，就会对其他源文件隐藏。
        2.默认初始化为0，包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的
        全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）
        3.保持局部变量内容的持久。静态局部变量的生存期为整个源程序，作用域仍与局部变量相同。
        
        类中static的作用：
        C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。
        1.静态数据成员
                static数据成员独立于该类的任意对象而存在。当某个类的实例修改了该静态成员变量，其修改值为该类的其他所有
                实例可见。static数据成员必须在类定义体的外部定义（正好一次）。
        2.静态成员函数
                1）静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数。静态成员函数不能访问非
                静态数据成员和非静态成员函数，非静态成员函数可以任意的访问静态数据成员和静态成员函数。
                
                2）由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许提升。


<br>

#### C++中const的作用

        在C++中，可以将变量定义为const，以表明它们不应该被修改，也可以将方法定义为const，表明它们不应该修改类的任何成员
        变量。
        
        方法的const正确性：
                1）位元常量性，const方法不应该修改类的任何成员变量。
                2）逻辑常量性，如果const方法对成员变量的修改不能被用户感知，那么const方法就可以修改成员变量。
                C++编译器遵从位元的方法，但有时候确实需要编译器表现出逻辑常量性方式。典型的例子是由于计算过于耗时想要缓
                存类的一些属性的情况。使用mutable关键字是维护API逻辑常量性的好方法，这样就不必去掉应该声明为const的成
                员函数的const关键字。
                
        参数的const正确性：
                可以使用const关键字表明将一个参数设计为输入参数还是输出参数，也就是说，它是用来给方法传递某个值的参数，
                还是用来接收某个结果的参数。如果有一个const方法，那么任何引用或指针参数也可能被声明为const的，尽管这
                不是一成不变的规定，但这在逻辑上遵循const函数不能修改任何状态这一惯常约定。
                
        返回值的const正确性：
                返回函数结果时，将结果声明为const的主要理由是其引用了对象的内部状态。如果以传值的方式返回一个结果，那
                么将其指定为const则毫无意义，因为返回的对象是一个副本，修改它不会影响类的任何内部状态。
                使用传值的方式返回更安全，因为既不必担心客户在对象被销毁后仍继续持有引用，也不会因为返回const引用而破
                坏封装性。
                
        实际上，从const的实现原理上来讲，const只是一个编译期的语言功能，做一些简单的常量替换以及赋值限制等，在运行时不会
        对内存有什么限制。不合理的使用const_cast之所以会造成运行时崩溃，是由于const修饰的某些变量是位于常量区或者其他某
        些只读的内存页。
        
      
<br>

#### C++中，static、const以及static const成员变量的初始化

        在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文
        件中初始化。
        
        在C++中，const成员也不能在类的定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。const数据成员只
        在某个对象生存期内是常量，而对整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不
        同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
        
        要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。
        
        class Test {
        public:
                Test()::a(0) {}
                enum {size1 = 100, size2 = 200};
        private:
                const int a;    // 只能在构造函数初始化列表中初始化
                static int b;   // 在类的实现文件中定义并初始化
                const static int c;     // 与static const int c;相同，c为整型，故也可在此处初始化，但仍需在定义体外进行
                                        // 定义，注意c为非整型时，不能在此处初始化，整型包括char、short、int、long
        };
        
        int Test::b = 0;        // static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象
        const int Test::c = 0;  // 给const static成员变量赋值时，不需要加static修饰符，但要加const


<br>

#### 在C++中使用const比使用#define有更多的优点。

        1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行安全类型检查。而对后者只进行字符替换，没有类
        型安全检查，并且在字符替换时可能会产生意想不到的错误。
        
        2）使用常量可能比使用#define导致产生更小的目标代码，这是因为预处理器“盲目地将宏名称BUFSIZE替换为其代替的值100”
        可能导致目标代码出现多份100的备份，但常量就不会出现这种情况。
        
        3）const还可以执行常量折叠（将常量表达式计算求值，并用求得的值来替换表达式），即编译器在进行编译时可以通过必要
        的计算把一个复杂的常量表达式缩减成简单的。


<br>

#### 二维数组

        声明与初始化：
        int ia[3][4] = {
                { 0, 1, 2, 3},
                { 4, 5, 6, 7},
                { 8, 9, 10, 11}
        };
        
        int ia[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
        
        动态声明a[m][n]：
        int **a = new int* [m];
        for (int i = 0; i < m; i++)
                a[i] = new int[n];
                
        for (int i = 0; i  < m; i++)
                delete[] a[i];
        delete[] a;


<br>

#### malloc/free与new/delete

        malloc/free是C/C++语言的标准库函数，new/delete是C++操作符。
        对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在
        销毁之前要自动执行析构函数。malloc仅仅分配内存，free仅仅回收内存，并不执行构造函数和析构函数。由于malloc/free
        是库函数而不是操作符，不在编译器控制的权限范围内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，
        C++需要一个能完成动态内存分配和初始化的运算符new，以及一个能完成清理与释放内存工作的运算符delete。


<br>

#### malloc的实现原理

        1）malloc函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表；
        
        2）调用malloc函数时，会沿着链表寻找一个大到足以满足用户请求所需的内存块，然后将该内存块一分为二（一块的大小与
        用户申请的大小相等，另一块的大小就是剩下来的字节）。接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的
        那块返回到链表上；

        3）调用free函数时，会将用户释放的内存块连接到空闲的链表上。

        4）空闲的链表会被切成很多的小内存片段，如果用户申请一个大的内存片段，这时，malloc函数请求延时，并开始在空闲链表
        上检查各内存片段，对其进行内存整理，将相邻的小空闲块合并成较大的内存块。


<br>

#### extern关键字

        1）在C语言中，extern用在变量或函数声明前，用来说明“此变量/函数在别处定义，要在此处引用”。
        
        2）在C++中，extern还有另外一种作用，用于指示C或者C++的调用规范。比如在C++中调用C库函数，就需要在C++程序中用
        extern "C" 声明要引用的函数。
        C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此
        会造成链接时找不到对应函数的情况，此时C函数就需要用extern "C" 进行链接指定，这告诉编译器，请保持我的名称，不要
        给我生成用于链接的中间函数名。


<br>

#### 显示类型转换

        1）dynamic_cast
                主要用于执行“安全向下转型（safe downcasting）”。也就是说，要确定一个对象是否是一个继承体系中的一个特定
                类型。它是唯一不能用旧风格语法执行的强制转换，也是唯一可能有重大运行时代价的强制转换。
                
        2）static_cast
                可以用于强制隐型转换（例如，non-const对象转型为const对象，int转型为double等）
                还可以用于很多这样的转换的反向转换（例如，void*指针转型为有类型的指针，基类指针转型为派生类指针）
                不能将const对象转型为non_const对象（只有const_cast）能做到
        
        3）const_cast
                用于强制消除对象的常量性。它是唯一能做到这一点的C++风格的强制转型。
        
        4）reinterpret_cast
                用于底层的强制转换，导致实现依赖（不可移植）的结果。例如，将一个指针转型为一个整数。这样的转型在底层代
                码以外应该极为罕见。


<br>

#### C++是不是类型安全的

        不是，两个不同类型的指针之间可以强制转换（用reinterpret_cast）。


<br>

#### 链表和数组

        数组将元素存放在连续的地址中，链表将数据存放在内存中的任意位置。这使得链表有巨大的扩展自己的灵活性，因为内存总
        是分散的。这种情况总是可能的：你无法创建一个数组来存放一百万个整数，但可以用链表来存放，因为空间总是存在的，只
        是不连续。其他的不同都源于这项事实。例如，在数组中，如果你知道下标，可以用O(1)的时间得到一个元素，但在链表中要
        花O(n)的时间。


<br>

#### 面向对象程序设计三大特点

        1）封装
                封装机制将数据和代码捆绑到一起，避免了外界的干扰和不确定性。一个对象就是一个封装了数据和操作这些数据的代
                码的逻辑实体。通过访问权限这种控制方式，对象对内部数据提供了不同级别的保护。
                
        2）继承
                继承可以让某个类型的对象获得另一个类型的对象的属性和方法。
                
        3）多态
                实现不同类的对象，对同一个方法的调用，产生不同的响应方式。


<br>

#### 派生类

        1）公有继承（public）
        对派生类来说
                基类的公共成员和保护成员可见：作为派生类的成员时，它们都保持原有的状态（公有和保护）
                基类的私有成员不可见：基类的私有成员仍然是私有的，且派生类不可访问基类中的私有成员。
        
        对派生类对象来说
                基类的公有成员时可见的，其他成员是不可见的。
                所以在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。
        
        2）私有继承（private）
        对派生类来说
                基类的公共成员和保护成员可见：基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类
                访问。
                基类的私有成员不可见：派生类不可访问基类的私有成员。
        
        对派生类的对象来说
                基类的所有成员都是不可见的。
                所以，在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。
        
        3）保护继承（protected）
        对派生类来说
                基类的公有成员和保护成员可见：基类的公有成员和保护成员都作为派生类的保护成员，并且不能被这个派生类的子类
                所访问。
                基类的私有成员不可见：派生类不可访问基类的私有成员。
        对派生类对象来说
                基类的所有成员都不可见。
                所以，在保护继承时，基类的成员只能由直接派生类访问，而无法再往下继续。
        
        
        在无继承的类中，protected和private控制符没有差别。在继承中，基类的private对所有外界都屏蔽（包括自己的派生类），基
        类的protected控制符对应用程序是屏蔽的，但对其派生类是可访问的。


<br>

#### 友元函数

        为什么要使用友元函数？
                在实现类之间的数据共享时，减少系统开销，提高效率。如果类A中的函数要访问类B中的成员，那么类A中的函数要是类
                B的友元函数。即允许外面的类或函数访问类的私有变量和保护变量，从而使两个类共享同一个函数。
        
        使用友元函数的优缺点？
                优点：能够提高效率，表达简单，清晰
                缺点：友元函数破坏了封装机制


<br>

#### 编码

        1）反码 = 除符号位按位取反的值
        2）补码 = 反码 + 1
        3）对补码求反加1即得原码；对原码求反加1即得补码
        
        负数在内存中用其补码表示。所以，对于char类型来说，10000000为-128,10000001为-127；11111111为-1。
        例如：
                char a = 256;
                int d = a;
                cout << d << endl;      // 输出0
        若把256改为255，则输出-1


<br>

#### sizeof和strlen的区别

        1）sizeof是一个操作符，strlen是库函数。
        2）sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字符串作参数。
        3）编译器在编译时就计算出了sizeof的结果，而strlen函数必须运行时才能计算出来，并且sizeof计算的数据类型占内存的大
        小，而strlen计算的是字符串的实际长度。
        4）数组做sizeof的参数不退化，传递给strlen就退化成指针了。


<br>

#### C++空类有哪些成员函数

        1）缺省构造函数
        2）缺省复制构造函数
        3）缺省析构函数
        4）缺省赋值运算符
        5）缺省取址运算符
        6）缺省取址运算符const
        
        只有当实际使用这些函数时，编译器才会去定义它们。
        

<br>

#### 为CMyString类中各函数补齐函数体

        class CMyString
        {
        public:
                CMyString(const char* pData = NULL);
                CMyString(const CMyString& other);
                ~CMyString();
                CMyString& CMyString::operator =(const CMyString &str);
                
        private:
                char* m_pData;
        }
        
        CMyString::CMyString(const char* pData)
        {
                if (pData == NULL)
                {
                        m_pData = new char[1];
                        *m_pData = '\0';
                }
                else
                {
                        int length = strlen(pData);
                        m_pData = new char[length+1];
                        strcpy(m_pData, pData);
                }
        }
        
        CMyString::CMyString(const CMyString &other)
        {
                int length = strlen(other.m_pData);
                m_pData = new char[length+1];
                strcpy(m_pData, other.m_pData);
        }
        
        CMyString::~CMyString()
        {
                delete[] m_pData;
        }
        
        CMyString& CMyString::operator =(const CMyString& str)
        {
                if (this == &str)
                        return *this;
                
                delete[] m_pData;
                m_pData = NULL;
                m_pData = new char[strlen(str.m_pData) + 1];
                strcpy(m_pData, str.m_pData);
                retrun *this;
        }
        
        定义一个赋值运算符函数需要注意以下几点：
        1）是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（*this）。只有返回一个引用，才可以允
        许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。
        
        2）是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函
        数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在复制运算符函数内不会改变传入的实例的
        状态，因此应该为传入的引用参数加上const关键字。
        
        3）是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的内存空间，程序将出现内存泄露。
        
        4）是否判断传入的参数和当前的实例（*this）是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先
        不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释
        放自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。


<br>

#### 复制构造函数与赋值运算符函数的区别

        1）复制构造函数生成新的类对象，赋值运算符则是在一个现存的对象赋予新的值时被调用。
        2）复制构造函数不返回任何值，void都没有。赋值运算符有返回值。
        
        当类中有指针类型的成员变量时，一定要重写复制构造函数和赋值运算符，不要使用默认的。


<br>

#### 对面向对象的认识

        面向对象可以理解为对待每一个问题，首先要确定这个问题由几部分组成，而每一个部分其实就是一个对象，然后再分别对这
        些对象进行设计，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是
        基于对象的角度来考虑问题。这样做能够使得程序更加简洁、清晰。


<br>

#### strcpy和memcpy的区别

        1）复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容。
        2）复制的方法不同。strcpy不需要指定长度，它遇到被复制字符串的结束符'\0'时才结束。memcpy则是根据第3个参数决定复
        制的长度。
        3）用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。


<br>

#### 如何引用一个已经定义过的全局变量

        可以用引用头文件的方式，也可以用extern关键字来引用已经定义过的全局变量。使用引用头文件的方式来引用某个头文件中
        的全局变量，如果变量名书写错误，在编译时提示错误；使用extern关键字引用时，如果变量名书写错误，则在链接时提示错
        误（因为extern是用来链接时指定）。
        

<br>

#### 转义字符

        若有说明语句：char c = '\72'；则变量c（）
        A. 包含1个字符          B. 包含2个字符          C. 包含3个字符          D. 说明不合法，c的值不确定
        
        转义字符是特殊的字符常量，"\"后面接一个或几个字符，整体表示一个转义字符，如"\n"是一个字符，代表回车。这里的"\72"
        是一个字符，72是八进制数，代表ASCII码（十进制数）":"。


<br>

#### 整数自动转换原则

        下面代码输出是什么？
        void food(void)
        {
                unsigned int a = 6;
                int b = -20;
                (a + b > 6) ? puts(">6") : puts("<6");
        }
        
        在C语言中无符号类型只能存放不带符号的整数，不能存放负数，当为其赋值为负数时，会自动转换为无符号的类型数值，其
        取值范围是0~65535。
        代码输出的是">6"，因为当表达式中存在有符号和无符号类型时，所有的操作数都自动转换为无符号类型。因此-20变成了一
        个非常大的正整数，所以该表达式计算出的结果大于6。


<br>

#### 加一运算的效率

        x = x + 1，x += 1，x++，哪个效率最高？
        
        第一个表达式 x = x + 1 的执行过程是先读取等号右边的x的地址，计算x+1的值，然后读取等号左边的x的地址，最后将等号
        右边的值传给等号左边的值；
        第二个表达式 x += 1 的执行过程是先读取等号右边的x的地址，计算x+1的值，最后将得到的值传给左边的x，因为x的地址已
        在前面读出，故省去了传值的过程；
        第三个表达式 x++ 的执行过程是先读取x的地址，然后x自增1；
        因此 x++ 的效率最高。


<br>

#### 定义一个宏实现两个数的交换

        有缺陷的实现：
        #define swap(x, y) int z = x; x = y; y = z;
        如果程序中已经定义了变量z，那么使用swap宏时，编译就会出错。
        例如：
        int main()
        {
                int z, a = 5, b = 10;
                swap(a, b);
                printf("%d, %d", a, b);
                return 0;
        }
        编译上述代码将出现z重定义的错误。
        
        在定义宏时应尽量避免定义额外的变量。本例中不借助第三方变量实现两个数值的互换，方法是：
        #define swap(x, y) x = x + y; y = x - y; x = x - y; 


<br>

#### 编写一个宏MIN，返回两个数的较小者

        错误的实现：
        #define MIN(x, y) (x > y ? y : x)
        如果采用下面的方法调用宏会出现副作用：
        MIN(a&0x10, b)
        程序的实际代码为：
        a&0x10 > b ? b : a&0x10;
        &运算符的优先级低于>运算符的优先级，因此通常结果不是我们预期的。
        
        正确的实现：
        #define MIN(x, y) ( (x) > (y) ? (y) : (x) )


<br>

#### #include <math.h>和#include "math.h"有何区别

        #include <math.h>表示编译器从标准库路径查找math.h文件。
        #include "math.h"表示编译器先查找工程路径，如果没有找到math.h文件，再查找标准库路径。
        

<br>

#### delete和delete[]的区别

        delete只调用一次析构函数，通常用于释放单个对象的堆空间。delete[]会调用数组中的每一个元素（类对象）的析构函数，
        用于释放对象数组的堆空间。
        

<br>

#### 数组与指针的区别

        存储方式：数组只能在静态存储区或栈上被创建，而指针可以随时随地的指向任意类型的内存块。
        
        内存容量：用运算符sizeof可以计算出数组的容量（字节数）。而对于指针，sizeof(p)，p为指针得到的是一个指针变量的
        字节数，而不是p所指的内存容量。
        
        内容上的差别：char a[] = "hello" 数组指向每个数组元素；char* p = "world"而p指向字符串首地址指针。
        

<br>

#### static函数和普通函数有什么区别

        static函数与普通函数的额区别是static函数在内存中只有一份，而普通函数在每个被调用中维持一份备份。
        

<br>

#### void指针

        void指针表示指向不属于任何类型的对象，它与空指针完全是两码事。所以void指针称为通用指针。
        void的指针可以应用于函数指针，也可以应用于纯粹的内存操作。
        

<br>

#### 各种复杂指针的声明

        技巧：
        首先找到要定义的标识符，一个声明里只能有一个要声明的标识符。
        找到标识符后，从标识符所在最里面的括号看起，先往右看，再往左看。每当遇到圆括号就调转阅读方向。括号里面的内容
        解析完成后就跳出括号重复这个过程直到结束。
        
        例如：
        float(**fa)[10]
        先找到标识符fa，它外面有一个圆括号，先看括号内。fa的左边是两个紧挨着的*号，说明fa是一个二级指针。括号里面解析
        完毕，看括号外面的右侧，有一个[10]，表明这个指针指向一个包含10个元素的一维数组。再看括号的左边，有一个float表
        明这个一维数组是float类型。
        
        double*(*sp)[10]
        sp左边是一个*号表示它是一个指针，跳出圆括号，右边是[]运算符，表明这个指针指向一个一维数组。再看左边，是一个*号，
        再左边是double类型，表明这个一维数组的元素都是指向double类型的指针。
        
        double(*arr[10])()
        arr是一个数组，arr有10个元素，元素都是函数的指针，指向的函数类型是没有参数且返回double的函数。
        
        long(*fun)(int)
        函数指针
        

<br>

#### 重载运算符

        C++中用友元函数重载运算符至少有一个参数，重载一目运算符要有一个参数，重载二目运算符要有两个参数。
        
        成员函数重载时，参数列表为空，是一元运算符；参数列表为1，是二元运算符。
        

<br>

#### 成员函数的重载、覆盖于隐藏

        成员函数被重载的特征：
        1）相同的范围（在同一个类中）；
        2）相同的函数名字；
        3）不同的参数列表；
        4）virtual关键字可有可无。
        
        成员函数被覆盖的特征：
        1）不同的范围（分别位于派生类和基类）；
        2）相同的函数名字；
        3）相同的参数；
        4）基函数必须有virtual关键字。
        
        隐藏是指在某些情况下，派生类中的函数屏蔽了基类中的同名函数，这些情况包括：
        1）两个函数参数相同，但基类不是虚函数。
        2）两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。
  
       
<br>

#### 共用体union

        结构体和共用体（联合）都是由多个不同的数据类型成员组成，但在任何同一时刻，共用体中只存放一个呗选中的成员，而
        结构体的所有成员都存在。对于共用体的不同成员赋值，将会对其他成员重写，原来的值就不存在了，而对结构体的不同成
        员赋值互不影响。
        共用体的用途之一是当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。
        
        结构体占用内存可能超过各成员内存量总和。
        共用体占用内存为各成员中占用最大者的内存。


<br>

#### struct所占用的内存

        struct _THUNDER {
                int iVersion;
                char cTag;
                char cAdv;
                int iUser;
                chat cEnd;
        }Thunder;
        int sz = sizeof(Thunder);
        
        对齐方式 4 1 1 (2) 4 1 (3)
        括号的数代表补充的空字节
        
        对齐方式：前面的长度必须为当前要添加字符长度的整数倍，到最后还要补齐使得最终长度是最长字符的整数倍。


<br>

#### 调用动态链接库函数有哪几种方法？

        1）在项目的配置工程的link设置中链入动态链接库对应的符号文件（lib文件），并在相应的代码文件中#include其对应的头
        文件，这样直接调用其函数即可；
        2）使用windows提供的LoadLibrary首先加载相应的dll文件，然后使用GetProcAdress这个API获得需要调用的函数指针，最后
        需要调用FreeLibrary释放这个dll文件，这种方法不需要使用lib文件。
        
<br>

#### C里面的struct和C++里的class的异同？

        1)C的struct与C++的class的区别？
        C是一种过程化的语言，struct只是作为一种复杂数据类型定义，struct中只能定义成员变量，不能定义成员函数。
        
        2）C++中struct与class的区别？
        访问权限上：class默认的成员访问权限是private的，而struct中则是public。
        继承上：class继承默认是private继承，而struct继承默认是public。
        其他：“class”这个关键字还用于定义模板参数，就像“typename”，但关键字“struct”不用于定义模板参数。
        

<br>

#### 面向对象与面向过程的区别？

        面向过程是自顶向下逐步编程，就是分析出解决问题所需要的步骤，其最重要的是模块化的思想方法。
        面向对象的方法主要是把事物给对象化，包括其属性和行为。抽象出对象的目的并不在于完成某个步骤，而是描述其在整个
        解决问题步骤中的行为。
        
        简单点说就是，面向过程就是把代码封装成函数，然后依次去做一件事情；面向对象就是你把要做的事情抽象成对象，告诉
        对象去做。面向对象的三大特性（封装、继承、多态）使得在做复杂的事情的时候效率和正确率得到保证。


<br>

#### final和override的作用，以及使用场合？

        final：禁止继承该类或覆盖该虚函数。
        override：必须覆盖基类匹配的虚函数。

        final使用场合：不希望类被继承，不希望子类去覆盖某个虚函数。

        override使用场合：
        1）覆盖一个基类的函数，但是参数不匹配或者名字拼错，结果导致写了一个新的虚函数。如果加上override，编译器会发
        现与基类函数不匹配从而给出编译错误的提示。
        2）在基类函数里对对应的函数加上override关键字，这样就会清楚的被知道该函数是否想被重写。


<br>

#### c++98/03有哪些不方便的用法？C++11使用到的新特性？

        auto，有一些迭代器的嵌套类型遍历时比较麻烦，auto写起来更方便。

        vector以及其他容器的列表初始化。

        nullptr，C++11前的NULL其实就是0，nullptr永远是指针类型，0可能会导致一些函数参数匹配问题，如f(int) f(foo *)。

        thread，不需要再使用其他库来写多线程了。

        share_ptr，一定程度上解决了内存泄露的问题。

        lambda function，简化结构简单的函数代码。


<br>

#### 一个C++源文件从文本到可执行文件经历的过程

        1）预处理，产生.ii文件；
        2）编译，产生汇编文件(.s文件)；
        3）汇编，产生目标文件(.o或.obj文件)；
        4）链接，产生可执行文件(.out或者.exe文件)。


<br>

#### 为什么要有线程？

        1）和进程相比，它是一种非常“节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配独立的地址空间，
        建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种“昂贵”的多任务工作方式。（资源）

        2）运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程之间彼此切换所需的时间也远远小于进程间
        切换所需要的时间。据统计，一个进程切换的开销大约是一个线程切换开销的30倍左右。（切换效率）

        3）线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式
        进行，这种方式不仅耗时，而且不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可
        以直接为其它线程所用，快捷又方便。（通信）

        除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：

        1）使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。（CPU设计保证）

        2）改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样代码更易于
        理解与维护。（易维护）


<br>

#### hash表的实现，包括STL中的哈希桶长度常数

        1）hash function（散列函数）。最常见的散列函数：f(x) = x % TableSize;

        2）碰撞问题（不同元素的散列值相同）。解决碰撞问题的方法包括线性探测、二次探测、链地址法（开链法）等。SGI的
        STL版本中使用的是开链法，使用一个链表保持相同散列值的元素。
        虽然开链法并不要求表格大小必须为质数，但SGI的STL版本仍然以质数来设计表格的大小，并且将28个质数（逐渐呈现大
        约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数中，“最接近某数并大于某数“的质数。


<br>

#### hash表如何rehash，怎么处理其中保存的资源

        为什么要rehash？
                因为当 loadFactory（负载因子） <= 1时，hash表查找的期望复杂度为O(1)。因此，每次往hash表中添加
        元素时，我们必须保证是在 loadFactory < 1 的情况下才能够添加。

        模仿C++中vector的扩容方式，Hash表中每次发现 loadFactory == 1 时，就开辟一个原来桶数组的两倍的空间（称为
        新桶数组），然后把原来的桶数组中的元素全部转移到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中。


<br>

#### 智能指针

        unique_ptr：unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于
        避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

        shared_ptr：shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引
        用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。
        可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, 
        unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，
        资源会被释放。
        shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供
        了可以共享所有权的智能指针。

        shared_ptr成员函数：
        1）use_count 返回引用计数的个数。
        2）unique 返回是否是独占所有权( use_count 为 1)。
        3）swap 交换两个 shared_ptr 对象(即交换所拥有的对象)。
        4）reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少。
        5）get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.
        如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

        weak_ptr：weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的
        内存管理的是那个强引用的 shared_ptr。 weak_ptr只是提供了对管理对象的一个访问手段。
        weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个
        shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决
        shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，
        资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr
        可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。


<br>

#### vector扩容原理

        1）开辟更大的空间；
        2）将旧空间元素开辟到新的空间；（调用复制构造函数去拷贝原有的对象至新的内存，如果是C++11，可以加上移动构造
        函数）。
        3）释放旧空间。（调用析构函数释放原有对象占用的内存）


<br>

#### 智能指针实现

        1)智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针；
        2)每次创建类的新对象时，初始化指针并将引用计数置为1；
        3)当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
        4)对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加
        右操作数所指对象的引用计数；这是因为左侧的5)指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数
        加1；
        6)调用析构函数时，减少引用计数，如果引用计数减至0，则删除基础对象和引用计数对象。
        
        template <typename T>
        class SharedPtr{
        public:
                SharedPtr : t_(nullptr), count_(nullptr) {}

                explicit SharedPtr(T* t) : t_(t)
                {
                        if (t)
                        {
                                count_ = new int(1);
                        }
                }

                explicit SharedPtr(const SharedPtr& rhs)
                {
                        t_ = rhs.t_;
                        count_ = rhs.count_;
                        if (count_)
                                (*count_)++;
                }

                ~SharedPtr() 
                {
                        reset();
                }

                SharedPtr& operator=(const SharedPtr& rhs)
                {
                        if (this == &rhs)
                                return *this;
                        
                        reset();
                        t_ = rhs.t_;
                        count_ = rhs.count_;
                        if (count_)
                                (*count_)++;
                        
                        return *this;
                }

                SharedPtr& operator*()
                {
                        return *this;
                }

                T* operator->() 
                {
                        return t_;
                }

                T* get() const
                {
                        return t_;
                }

                int count() const
                {
                        return count_ ? *count_ : 0;
                }

                void reset()
                {
                        if (count_)
                        {
                                (*count_--);
                                if (*count_ == 0)
                                {
                                        delete t_;
                                        delete count_;
                                }
                        }
                }

        private:
                T* t_;
                int* count_;
        };

