## 图形渲染相关知识

#### 渲染管线

        （1）顶点着色器
        此阶段是完全可编程的。此阶段的输入是单个顶点（虽然实际上会并行处理多个顶点）。顶点位置及法矢量通常以模型空间或世界空间表示。
        此阶段也会进行透视投影、每顶点光照及纹理计算，以及为动画角色计算蒙皮。顶点着色器也可以通过修改顶点位置来产生程序式动画。例
        如模拟风吹草动或碧波荡漾。此阶段的输出是完成变换以及光照后的顶点 ，其位置及法矢量是以其次裁剪空间表示的。（顶点通过投影矩阵
        从观察空间转换到齐次裁剪空间）

        （2）几何着色器
        可选的几何着色阶段也是完全可编程的。几何着色器处理以齐次裁剪空间表示的整个图元（三角形、线段、点）。它能剔除或修改输入的图
        元，又能生成新的图元。其典型应用包括阴影体积拉伸(shadow volume extrusion)、渲染立方体贴图(cube map)的6个面、在网络
        的轮廓边拉伸毛发的鳍、从点数据生成粒子四边形、动态镶嵌、把线段以分形细分模拟闪电效果、布料模拟等。

        （3）流输出
        现在的GPU容许把达致此管道阶段的数据写回内存。数据能从那里回到管道之始做进一步处理。此功能称为流输出(stream out)。
        通过使用流输出，许多迷人的效果可以不经过CPU实现。其中一个绝佳的例子是头发渲染。头发通常是由三次样条曲线(cubic spline 
        curve)的集合表示的。以往头发通常在CPU上进行物理模拟，然后在CPU上把样条镶嵌为线段，最后由GPU渲染那些线段。
        有了流输出，GPU便可于顶点着色器内，在头发样条的控制点上进行物理模拟。几何着色器则把样条镶嵌成线段，并用流输出功能把镶嵌后的
        顶点数据写入内存。最后那些线段被重新流入管道之始去渲染。

        （4）裁剪
        裁剪(clipping)阶段把三角形在平截头体以外的部分切掉。其原理是先判定哪些顶点在平截头体以外，然后求出三角形的棱和平截头体的平
        面之间的相交点。这些相交点会成为一个或多个裁剪后三角形的新顶点。
        此阶段是固定功能，但提供有限度配置。例如，除了平截头体的平面外，用户能定义额外的裁剪平面。此阶段也能配置剔除完全在平截头体以
        外的三角形。

        （5）屏幕映射
        屏幕映射(screen mapping)只是简单地缩放和平移顶点，使之从齐次裁剪空间变换至屏幕空间。此阶段是完全固定且不能配置的。

        （6）三角形建立
        自三角形建立(triangle setup)阶段，光栅化硬件开始迅速把三角形转化成片段。此阶段是不能配置的。

        （7）三角形遍历
        三角形遍历(triangle setup)阶段把三角形分解为片段（即光栅化）。通常每个像素会产生一个片段，除非是使用MSAA，那么每个像素会
        产生多个片段。三角形遍历也会对顶点属性进行插值，以产生每片段(per-fragment)属性，供像素着色器使用。此阶段的功能也是固定且不
        能配置的。

        （8）提前深度测试
        许多显卡能够在管道的此时间点检查片段的深度，若某片段会被帧缓冲的像素遮挡，就在此丢弃该片段。这么做对于所有被遮挡片段，能直接
        跳过（可能非常耗时的）像素着色器阶段。
        并非所有图形硬件都支持在此管道阶段进行深度测试。在过去的GPU设计中，深度测试和alpha测试都是在像素着色器之后才进行的。因此，
        此阶段成为提前z测试或提前深度测试。

        （9）像素着色器
        像素着色器是完全可编程阶段。其工作是替每个像素着色（即光照及其他处理）。像素着色器也能丢弃一些片段，例如，某些片段被判断为完
        全透明。像素着色器可以对多个纹理采样、计算每像素光照以及任何会影响片段颜色的计算。
        此阶段的输入是一个每片段属性（这些属性是在三角形遍历中通过对顶点属性插值所得）。而输出是一个颜色矢量，代表所要的片段颜色。
        
        （10）合并/光栅运算阶段
        管道的最终阶段为合并阶段(merge stage)或混合阶段(blending stage)，NVIDIA称之为光栅运算阶段(raster operations 
        stage)。
        此阶段不能编程，但能高度配置。此阶段负责执行多个片段测试，包括深度测试、alpha测试，以及模板测试。

<br>

#### 将一个局部坐标系中的点转换到屏幕上的二维点，需要经历的计算过程

        （1）由局部空间转换到世界空间
                worldPos = modelMat * modelPos
        （2）由世界空间转换到观察空间
                viewPos = viewMat * worldPos
        （3）由观察空间转换到齐次裁剪空间
                homogeneousPos = projectionMat * viewPos
        （4）齐次坐标转换为三维坐标
                clipPos = homogeneousPos / w
        （5）由齐次裁剪空间转换到屏幕空间（屏幕映射）
                (clipPos.x + 1.0) * 0.5 * (width - 1.0)
                (clipPos.y + 1.0) * 0.5 * (height - 1.0)
        
        渲染以齐次裁剪空间表示的三角形时，可以只用其x、y坐标而忽略z。

        当点或矢量从三维延伸至四维，便称为齐次坐标(homogeneous coordinates)。当要把齐次坐标转换为三维坐标时，要把x、y、z分量
        除以w。
        进行透视投影后，每个顶点的x和y坐标会除以其z坐标。这个除法是产生透视收缩的方法。

<br>

#### 深度缓冲

        深度缓冲是全屏缓冲，当中的每个像素含16或24位的深度数据。每个片段含有一个z坐标，以量度其“深入”屏幕的深度（片段的深度是从
        对三角形顶点深度插值所得）。当片段的颜色写入帧缓冲，其深度就会储存在对应的深度缓冲像素里。而当另一片段（自另一个三角形）
        渲染在同一像素时，引擎就会比较新的片段深度和深度缓冲里的现存深度。若新片段比较接近摄像机，其颜色及深度就会写进帧缓冲。
        否则该片段就会丢弃。

        要想有正确的投影性质，需要使用一个非线性的深度方程，它是与1/z成正比的。它做的就是再z值很小的时候提供非常高的精度，而在z值
        很小的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？
        深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。

<br>

#### 半透明物体的渲染

        要令alpha混合显示正常，必须先渲染场景中不透明的几何物体至帧缓冲，然后把半透明的表面从后往前排序渲染。这样做的原因是，深度
        缓冲会忽略透明度（除非关掉深度写入）。如果要在不透明的物体上渲染一堆半透明的物体，那么理想的最终像素颜色要与那堆半透明的物
        体的所有表面混合。若采用任何从后至前以外的次序渲染，有些半透明片段的深度测试便会失败，导致那些片段丢弃，最终造成不完整的混
        合。

<br>

#### 着色器内存访问

        着色器程序不能直接读写内存。取而代之，其内存访问只限于两个方法：寄存去和纹理贴图。

<br>

#### 着色器寄存器的数据传递

        输入寄存器：这些寄存器是着色器的主要数据输入来源。在顶点着色器中，输入寄存器含有顶点的属性数据。在像素着色器中，输入寄存器
        含有对应某片段的顶点属性插值数据。在调用着色器之前，GPU会自动设置这些输入寄存器的值。
        常数寄存器：常数寄存器的值是由应用程序设置的，应用程序按不同图元会设置不同的值。所谓常数，只是对着色器而言。常数寄存器是着
        色器的另一种输入。其典型的内容包括模型观察矩阵、投影矩阵、光照参数以及其他着色器所需但顶点属性不包含的数据。
        临时寄存器：这些寄存器只供着色器程序内部使用，通常用于存储中间计算结果。
        输出寄存器：这些寄存器的内容由着色器填充，作为着色器仅有的输出形式。在顶点着色器中，输出寄存器含有顶点属性，例如，以齐次裁
        剪空间表示的已变换的位置及法矢量、可选的颜色、纹理坐标等。在像素着色器中，输出寄存器包含正在着色的片段的最终颜色。

        当提交几何图元渲染时，应用程序要提供常数寄存器的值。在调用着色器程序之前，GPU会从显存自动复制顶点或片段属性数据至适当的输
        入寄存器；当程序执行完成，GPU会把输出寄存器的内容写入显存，使数据能给予下个管道阶段。
        GPU通常会把输出数据储存至缓存，这些数据能重用而不需要重新计算。例如，变换后的顶点缓存是用来储存顶点着色器最近处理过的结
        果。如果某三角形刚好引用到之前已处理过的顶点，那么可行的话GPU就会读取变换后的顶点缓存——只有当缓存中的顶点被丢弃后，才需
        要再对相同的顶点执行顶点着色器。

<br>

#### 法线贴图

        法线贴图（normal map）中，每个纹素代表表面法矢量的方向。法矢量通常会在纹理的RGB颜色通道中编码。由于RGB颜色通道必须为正
        数，而法矢量的分量可为负数，所以为法矢量编码时会加上合适的偏置（bias），最常见的法线贴图是储存切线空间（tangent space）。
        假设表面法矢量都是单位矢量，那么有时候只需在纹理中储存两个坐标，第３个坐标能较简易地在运行时计算得出。

<br>

#### 高度贴图

        高度贴图（height map）是用来编码高于或低于三角形表面的理想高度。因为每个纹理只需单个高度值，所以高度贴图通常编码为灰阶
        影像。高度贴图通常用于视差贴图法（parallax mapping）及浮雕贴图（relief mapping）技术。这两个技术都能令平面表面显得
        有强烈的高度变化，能制造出自遮挡（self-occlusion）及自阴影（self-shadow）的效果。

<br>

#### 镜面/光泽贴图

        若我们把表面镜面反射率的值存进镜面贴图的纹素，就能控制每个纹素的位置能造成多少镜面反射。这一种镜面贴图有时会称为光泽贴图
        （gloss map）。这种贴图也会称为镜面遮罩（specular mask），因为０值的纹素能“遮盖”不想要有镜面反射的表面部分。若在镜面
        贴图中存储镜面幂（specular power）的值，那么我们可以控制每纹素位置镜面高光的集中程度。这种纹理称为镜面幂纹理贴图
        （specular power map）。

<br>

#### 阴影贴图

        所谓阴影贴图技术，实际上是进行每片段的深度测试，但该“深度”并非从摄像机的视角去计算，而是从光源的视角计算。使用阴影贴图时，
        需要把场景渲染两次。首先，从光源的视角渲染场景，把渲染结果的深度缓冲储存为阴影贴图纹理。然后，以正常的方式渲染场景，渲染
        每个片段时使用阴影贴图判断该片段是否在阴影中。而判断的方法是，若该片段自光源的距离比阴影贴图里的对应深度值远，那么便代表
        该片段被遮挡，也就是位于阴影范围内。这一过程的原理，等同于使用深度缓冲判断片段是否被较近的三角形遮挡。

<br>

#### 环境遮挡（ambient occlusion）
        量度某点AO值的方法是，以该点为球心设一个非常大半径的半球体，然后计算从该点可见的半球表面面积百分比。由于AO与观察方向及入
        射光方向无关，静态物体的AO可以在脱机时预计算，计算结果通常会存储为纹理。
        上述的AO计算是基于几何方法的，而另一种近年流行的方法是在屏幕空间计算。后者称为屏幕空间环境遮挡
        （screen-space ambient occlusion, SSAO）。

<br>

#### 延迟渲染（deferred rendering）

        在延迟渲染中，主要的光照计算是在屏幕空间进行的，而非观察空间。我们首先迅速的渲染不含光照的场景。在此阶段，我们把所有将用于光照计算的信息储存在一个“深厚的”帧缓存里，此缓冲称为几何缓冲（geometry buffer, G-buffer）。完成场景渲染后，就使用几何缓冲的信息来计算光照和着色。这样做通常比观察空间光照更高效，又避免了着色器版本的增长，并且可以相对容易的渲染一些非常悦目的效果。




